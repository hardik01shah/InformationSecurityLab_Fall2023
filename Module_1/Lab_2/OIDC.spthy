theory OIDC
/* Model of a simplified version of the OpenID-connect Implicit Flow protocol.
   OpenID connect specification: https://openid.net/specs/openid-connect-core-1_0.html*/

begin

//Do not change the following line, i.e. do not add, change or remove anything (not even comments) in the following line.
builtins: signing

/*
Agents that take part in the protocol:
- User: end-user (including the browser)
- RP: Relaying Party: the serivce (e.g. webpage) the user wants to access to
- IdP: Identity Provider: the authorization server that is capable of authenticating end-users 
*/


/*Public key infrastructure*/
//Only the IdP has a private/public key. 

/* The following rule should be annotated by the following action fact:
- IdP_initializes($IdP, ~skey) : indicating $IdP generated key ~skey
*/
rule IdPgeneratesKeyPair:
/*FILL IN HERE*/
    [Fr(~skey)]
  --[IdP_initializes($IdP, ~skey)]->
    [!Ltk($IdP, ~skey), !Pk($IdP, pk(~skey)), Out(pk(~skey))]

/* The following rule should be annotated by the following action fact:
- Compromised($A) : indicating agent $A got compromised 
                            and their secret key was published.
*/
rule CompromiseAgent:
/*FILL IN HERE*/
    [!Ltk($IdP, ~skey)]
  --[Compromised($IdP)]->
    [Out(~skey)]


// Secure Channel rules.
// We assume that the User and the IdP communicate using TLS. We model communication with TLS with a secure channel
// Communication between the User and the RP is however not assumed to go through TLS. 

// Out_S($A,$B,x) indicates that agent $A is sending to agent $B$ a message x. 
// In_S($A,$B,x) indicates that agent $B is receiving from agent $A$ the message x. 
//Do not change the following two rules, i.e. do not add, change or remove anything (not even comments) in the following nine lines.
rule ChanOut_S:
    [ Out_S($A,$B,x) ]
  --[ ChanOut_S($A,$B,x) ]->
    [ Sec($A,$B,x) ]

rule ChanIn_S:
    [ Sec($A,$B,x) ]
  --[ ChanIn_S($A,$B,x) ]->
    [ In_S($A,$B,x) ]



/*Initialization Rules*/

/* This rule indicates $User registered with username ~username and password ~password
at $Server (either an RP or IdP)
*/
//Do not change the following rule, i.e. do not add, change or remove anything (not even comments) in the following nine lines.
rule Register_User_account:
    [ Fr(~username), Fr(~password)]
  --[ Username_belongs_to(~username, $User, $Server), 
      Only_once($User, $Server)
    , Is_User($User)
    , Is_Server($Server)
    , Register_User_account($User, $Server, ~username, ~password) ]->
    [ !User_account($User, $Server, ~username, ~password),
      !PasswordLookUp($Server, ~username, ~password) ]



/* Protocol Rules */

/*Authentication Request*/

//The user starts a session with a RP
/* The following rule should be annotated by the following action facts: 
- User_starts($User, $RP)
*/
rule User_starts:
    /*FILL IN HERE*/
let
    m_out = <$User, 'login'>
in
    [Fr(~tid)]
  --[User_starts($User, $RP)]->
    [UserSentLoginRequest($User, ~tid, $RP), Out(m_out)]

//The RP responds asking for credentials or choosing OIDC
/* The following rule should be annotated by the following action facts: 
- RP_responds($User, $RP)
*/
rule RP_responds:
    /*FILL IN HERE*/
let
    User_Rec = fst(m_in)
    txt = snd(m_in)
    m_out = 'sendCredentialsOrChooseOIDC'
in
    [Fr(~tid), In(m_in)]
  --[RP_responds($User, $RP), Eq($User, User_Rec), Eq(txt, 'login')]->
    [RPSentChoice($RP, ~tid, $User), Out(m_out)]

//If user has an account with the RP it directly sends it its credentials..
/* The following rule should be annotated by the following action facts: 
- User_Chooses_Direct_Login($User, $RP, ~username, ~password)
*/
rule User_Chooses_Direct_Login:
    /*FILL IN HERE*/
let
    m_out = <'username', ~username, 'password', ~password>
in
    [UserSentLoginRequest($User, ~tid, $RP), !User_account($User, $RP, ~username, ~password), In(m_in)]
  --[User_Chooses_Direct_Login($User, $RP, ~username, ~password),
     Eq(m_in, 'sendCredentialsOrChooseOIDC'),
     User_sends_credentials($User, $RP)]->
    [UserChoseDirectLogin($User, ~tid, $RP, ~username, ~password), Out(m_out)]


//which are checked by the RP, and if successful, logged in.
/* The following rule should be annotated by the following action facts: 
- RP_Receives_Credentials($RP, $User, ~username, ~password)
*/
rule RP_Receives_Credentials:
    /*FILL IN HERE*/
let
    txt1 = fst(m_in)
    user_recvd = fst(snd(m_in))
    txt2 = fst(snd(snd(m_in)))
    psswd_recvd = snd(snd(snd(m_in)))
in
    [RPSentChoice($RP, ~tid, $User), !PasswordLookUp($RP, ~username, ~password), In(m_in)]
  --[RP_Receives_Credentials($RP, $User, ~username, ~password),
     Eq(txt1, 'username'), Eq(txt2, 'password'),
     Eq(user_recvd, ~username), Eq(psswd_recvd, ~password),
     RP_accepts_credentials($RP, ~username),
     RP_Logs_User_in_Direct($RP, $User, ~username)]->
    []


//If the user wants to log-in through an IdP, it indicates this to the RP
/* This rule should be annotated by the following action facts: 
- Neq($RP,$IdP) : indicating that the $IdP is not the $RP.
- Not_an_IdP($RP) : indicating that the $RP is not registered as IdP.
- User_Chooses_OIDC($User, $RP, $IdP, ~username, ~password)
*/
rule User_Chooses_OIDC:
     /*FILL IN HERE*/
let
    m_out = <'loginWith', $IdP>
in
    [UserSentLoginRequest($User, ~tid, $RP), !User_account($User, $IdP, ~username, ~password), In(m_in)]
  --[Neq($RP,$IdP), Not_an_IdP($RP),
     User_Chooses_OIDC($User, $RP, $IdP, ~username, ~password),
     Eq(m_in, 'sendCredentialsOrChooseOIDC')]->
    [UserChoseOIDCLogin($User, ~tid, $RP, $IdP, ~username, ~password), Out(m_out)]


//The RP answers with an Authentication Request...
/* The following rule should be annotated by the following action facts: 
- AuthRequest_RP($RP, $User, $IdP, ~nonce)
*/
//Do not change the following two lines, i.e. do not add, change or remove anything (not even comments) in the following two lines.
rule AuthRequest_RP:
    [ In(<'loginWith', $IdP>),
    /*FILL IN HERE*/
    RPSentChoice($RP, ~tid, $User), Fr(~nonce), !Pk($IdP, pk_idp)
    ]
    /*FILL IN HERE*/
    --[AuthRequest_RP($RP, $User, $IdP, ~nonce)]->
    [RPSentAuthRequest($RP, ~tid, $User, $IdP, ~nonce), Out(<'authRequest', ~nonce>)]

//...which is forwarded by the user to the IdP it had indicated
/* The following rule should be annotated by the following action facts: 
- AuthRequest_User($User, $RP, $IdP, ~username, ~password, nonce)
*/
rule AuthRequest_User:
    /*FILL IN HERE*/
let
    txt1 = fst(m_in)
    nonce = snd(m_in)
    m_out = <'authRequest', $RP, nonce>
in
    [UserChoseOIDCLogin($User, ~tid, $RP, $IdP, ~username, ~password), In(m_in)]
  --[AuthRequest_User($User, $RP, $IdP, ~username, ~password, nonce), Eq(txt1, 'authRequest')]->
    [UserSentAuthRequest($User, ~tid, $RP, $IdP, ~username, ~password, nonce), Out_S($User, $IdP, m_out)]

//The IdP gets the Request and asks the user to authenticate.
/* The following rule should be annotated by the following action facts: 
- AuthRequest_IdP($IdP, $User, $RP, nonce, ~skey)
*/
rule AuthRequest_IdP:
    /*FILL IN HERE*/
let
    txt1 = fst(m_in)
    RP_recvd = fst(snd(m_in))
    nonce = snd(snd(m_in))
    m_out = <'Auth', 'giveConsent', $RP>
in
    [Fr(~tid), !Ltk($IdP, ~skey), In_S($User, $IdP, m_in)]
  --[AuthRequest_IdP($IdP, $User, $RP, nonce, ~skey),
     Eq(txt1, 'authRequest'), Eq($RP, RP_recvd)]->
    [IdPSentAuth($IdP, ~tid, $User, $RP, nonce, ~skey), Out_S($IdP, $User, m_out)]


//The user authenticates and gives consent.
/* This rule should be annotated by the following action facts: 
- User_Authenticates($User, $RP, $IdP, ~username, ~password, nonce)
*/
rule User_Authenticates:
    /*FILL IN HERE*/
let
    txt1 = fst(m_in)
    txt2 = fst(snd(m_in))
    RP_recvd = snd(snd(m_in))
    m_out = <~username, ~password, 'consent', $RP>
in
    [UserSentAuthRequest($User, ~tid, $RP, $IdP, ~username, ~password, nonce), In_S($IdP, $User, m_in)]
  --[User_Authenticates($User, $RP, $IdP, ~username, ~password, nonce),
     Eq(txt1, 'Auth'), Eq(txt2, 'giveConsent'), Eq($RP, RP_recvd),
     User_gives_consent($User, $RP, $IdP)]->
    [UserSentConsent($User, ~tid, $RP, $IdP, ~username, ~password, nonce), Out_S($User, $IdP, m_out)]



//The IdP receives the user's consent and sends the authentication Resoponse containing the ID Token.
/* This rule should be annotated by the following action facts: 
- Authentication_Response_IdP($IdP, $User, $RP, ~username, ~password, nonce)
*/
rule Authentication_Response_IdP:
    let token = <'idToken'
        /*FILL IN HERE*/
        , <'iss', $IdP>
        , <'sub', ~username>
        , <'aud', $RP>
        , <'nonce', nonce>>
        user_recvd = fst(m_in)
        psswd_recvd = fst(snd(m_in))
        txt1 = fst(snd(snd(m_in)))
        RP_recvd = snd(snd(snd(m_in)))
        m_out = <token, sign(token, ~skey)>
    in
    /*FILL IN HERE*/
    [IdPSentAuth($IdP, ~tid, $User, $RP, nonce, ~skey), !PasswordLookUp($IdP, ~username, ~password), In_S($User, $IdP, m_in)]
  --[Authentication_Response_IdP($IdP, $User, $RP, ~username, ~password, nonce),
     Eq(txt1, 'consent'), Eq(RP_recvd, $RP),
     Eq(user_recvd, ~username), Eq(psswd_recvd, ~password)]->
    [IdPSentAuthResponse($IdP, ~tid, $User, $RP, nonce, ~skey, ~username, ~password), Out_S($IdP, $User, m_out)]



//The User forwards the ID Token to the RP (without looking at its content!).
/* This rule should be annotated by the following action facts: 
- Authentication_Response_User($User, $RP, $IdP, ~username, ~password, nonce, id_token, signedtoken)
*/
rule Authentication_Response_User:
    /*FILL IN HERE*/
let
    id_token = fst(m_in)
    signedtoken = snd(m_in)
in
    [UserSentConsent($User, ~tid, $RP, $IdP, ~username, ~password, nonce), In_S($IdP, $User, m_in)]
  --[Authentication_Response_User($User, $RP, $IdP, ~username, ~password, nonce, id_token, signedtoken)]->
    [UserSentAuthResponse($User, ~tid, $RP, $IdP, ~username, ~password, nonce, id_token, signedtoken), Out(m_in)]


//The RP gets the  ID Token and validates it, logging the user in.
/* This rule should be annotated by the following action facts: 
- RP_gets_IDToken($RP, $User, $IdP, ~nonce, username, id_token, signedtoken, pk_idp)
*/
rule RP_gets_IDToken:
   /*FILL IN HERE*/
let
    id_token = fst(m_in)
    signedtoken = snd(m_in)

    txt1 = fst(id_token)
    iss = fst(snd(id_token))
    sub = fst(snd(snd(id_token)))
    aud = fst(snd(snd(snd(id_token))))
    non = snd(snd(snd(snd(id_token))))

    iss_txt = fst(iss)
    Idp_recvd = snd(iss)

    sub_txt = fst(sub)
    username = snd(sub)

    aud_txt = fst(aud)
    RP_recvd = snd(aud)

    non_txt = fst(non)
    nonce_recvd = snd(non)

in
    [RPSentAuthRequest($RP, ~tid, $User, $IdP, ~nonce), !Pk($IdP, pk_idp), In(m_in)]
  --[RP_gets_IDToken($RP, $User, $IdP, ~nonce, username, id_token, signedtoken, pk_idp),
     Eq(verify(signedtoken, id_token, pk_idp), true),
     Eq(txt1, 'idToken'),
     Eq(iss_txt, 'iss'), Eq(Idp_recvd, $IdP),
     Eq(sub_txt, 'sub'),
     Eq(aud_txt, 'aud'), Eq(RP_recvd, $RP),
     Eq(non_txt, 'nonce'), Eq(nonce_recvd, ~nonce),
     RP_Logs_User_in_OIDC($RP, $User, username, $IdP),
     RP_gets_IDToken_for_username($RP, username, $IdP),
     RP_gets_IDToken_for_user($RP, $User, id_token, $IdP)]->
    []



/*Restrictions*/
//Equality or Inequality - comment out if not needed:
restriction Inequality:
    "All x #i. Neq(x,x) @ #i ==> F"

restriction Equality:
  "All x y #i. Eq(x,y) @#i ==> x = y"

//Restriction an RP to not be registered as an IdP.
//Do not change the following restriction, i.e. do not add, change or remove anything (not even comments) in the following two lines.
restriction RP_shouldnt_be_an_IdP:
    "All rp #i. Not_an_IdP(rp)@i ==> not(Ex x #j. IdP_initializes(rp, x)@j)"

//Each user should have one account.
//Do not change the following restriction, i.e. do not add, change or remove anything (not even comments) in the following three lines.
restriction OneAccount:
    " All idp u #i #j. (Only_once(u, idp)@i & Only_once(u, idp)@j)
    ==> (#i = #j )"


//Each IdP should only generate a private/public key pair once.
//Do not change the following restriction, i.e. do not add, change or remove anything (not even comments) in the following three lines.
restriction IdP_initializes_Once:
    " All idp v u #i #j. (IdP_initializes(idp, v)@i & IdP_initializes(idp, u)@j)
    ==> (#i = #j & u = v)"


//A user is not a server. i.e. users can not have accounts with users.
//Do not change the following restriction, i.e. do not add, change or remove anything (not even comments) in the following three lines.
restriction Users_are_not_Servers:
  " All user #i. Is_User(user)@i 
  ==> not (Ex #j. Is_Server(user)@j) "

//Trace existence lemmas

//Do not change this lemma, i.e. do not add, change or remove anything (not even comments) in the following nine lines.
lemma executableRP:
 exists-trace
  "Ex usr rp username password #i #j.
    ( RP_Receives_Credentials(rp, usr, username, password)@i
    & User_Chooses_Direct_Login(usr, rp, username, password)@j
    & #j<#i
    & not (Ex usr2 rp2 username2 password2 #j2. 
      User_Chooses_Direct_Login(usr2, rp2, username2, password2)@j2
      & not (#j = #j2)))"

//Do not change this lemma, i.e. do not add, change or remove anything (not even comments) in the following eleven lines.
lemma executable_IdP:
 exists-trace
  "Ex #i #j #k #m usr username rp idp id_token signedtoken pk_idp password nonce. 
    (RP_gets_IDToken(rp, usr, idp, nonce, username, id_token, signedtoken, pk_idp)@i
    & Authentication_Response_IdP(idp, usr, rp, username, password, nonce)@m & #m<#i 
    & Register_User_account(usr, idp, username, password)@k
    & User_Chooses_OIDC(usr, rp, idp, username, password)@j & #j<#m ) 
    & ( not (Ex idp #k. Compromised(idp)@k) )
    & ( All #n usr2 rp2 idp2 username2 password2. 
      User_Chooses_OIDC(usr2, rp2, idp2, username2, password2)@n
        ==> #j = #n )"


//Security properties:
/* To formalize the following security properties, you may only use the following nine action facts:
        - User_sends_credentials($User, $RP)
        - User_gives_consent($User, $RP, $IdP)
        - Username_belongs_to(~username, $User, $Server): (Already part of skeleton)
        - RP_accepts_credentials($RP, ~username)
        - RP_Logs_User_in_Direct($RP, $User, ~username)
        - RP_Logs_User_in_OIDC($RP, $User, username, $IdP)
        - RP_gets_IDToken_for_username($RP, username, $IdP)
        - RP_gets_IDToken_for_user($RP, $User, id_token, $IdP) 
        - Compromised($A): (to be added to rule CompromiseAgent)
*/

//an RP $RP accepts a username-password pair, only if the user corresponding to that username has earlier sent these credentials to that RP
//un-comment following line for Task 1.2
lemma User_gives_Credentials [heuristic=S] :
    /*FILL IN HERE*/
    "All rp username #i.
        RP_accepts_credentials(rp, username)@i
        ==> (Ex user #j #r.
             User_sends_credentials(user, rp)@j & 
             (#j<#i) & Username_belongs_to(username, user, rp)@r & (#r<#j))"

//an RP $RP should receive and accept an ID Token from a non-compromised IdP $IdP for username only if the user corresponding to that username has previously consented to the  $IdP to give $RP such ID Token.
//un-comment following line for Task 1.2
lemma User_gives_Consent_to_RP_getting_IDToken [heuristic=S] :
    /*FILL IN HERE*/
    "All rp username idp #i.
        RP_gets_IDToken_for_username(rp, username, idp)@i
        ==> (Ex user #j #r.
             User_gives_consent(user, rp, idp)@j & 
             (#j<#i) & Username_belongs_to(username, user, idp)@r & (#r<#j)) | 
             (Ex #v. Compromised(idp)@v)"

//An RP $RP logs a user in via Direct Login with a certain username, only if this user is the actual owner of the username for that RP.
//un-comment following line for Task 1.2
lemma User_Logged_In_Direct [heuristic=S] :
/*FILL IN HERE*/
    "All rp user username #i.
        RP_Logs_User_in_Direct(rp, user, username)@i
        ==> (Ex #j. Username_belongs_to(username, user, rp)@j & 
             (#j<#i))"

//An RP logs a user in with a username username received in a valid ID Token from a non-compromised $IdP, only if the user is the actual owner of the username username with that IdP.
//un-comment following line for Task 1.2
lemma User_Logged_In_OIDC [heuristic=S] :
    /*FILL IN HERE*/
    "All rp user username idp #i.
        RP_Logs_User_in_OIDC(rp, user, username, idp)@i
        ==> (Ex #j. Username_belongs_to(username, user, idp)@j & 
             (#j<#i)) | 
             (Ex #v. Compromised(idp)@v)"

// If a RP receives valid credentials (i.e. username and password pair) for user $User, it cannot validate the same credentials from different User $User2.
//un-comment following line for Task 1.2
// lemma Unique_Credentials [heuristic = S] :
    /*FILL IN HERE*/
    // "All rp username #i.
    //     RP_accepts_credentials(rp, username)@i
    //     ==> (Ex user #j #r.
    //          User_sends_credentials(user, rp)@j & 
    //          (#j<#i) & Username_belongs_to(username, user, rp)@r & (#r<#j))"


//If a RP receives a valid ID Token from a non-compromised IdP $IdP for user $User, it cannot validate the same ID Token for a different User $User2
//un-comment following line for Task 1.2
lemma Unique_IDToken [heuristic = S] :
    /*FILL IN HERE*/
    "All rp user1 token idp #i. 
        RP_gets_IDToken_for_user(rp, user1, token, idp)@i
        ==> not (Ex user2 #j.
            RP_gets_IDToken_for_user(rp, user2, token, idp)@j & 
            (not (user1 = user2))) | 
            (Ex #v. Compromised(idp)@v)"

end
